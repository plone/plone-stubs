from _typeshed import Incomplete
from threading import local
from zope.proxy import non_overridable
from zope.proxy import ProxyBase

UNINDEX: int
REINDEX: int
INDEX: int
logger: Incomplete
debug: Incomplete
localQueue: Incomplete
processing: Incomplete

class PortalCatalogProcessor:
    """An index queue processor for the standard portal catalog via
    the `CatalogMultiplex` and `CMFCatalogAware` mixin classes"""
    def index(self, obj, attributes=None) -> None: ...
    def reindex(self, obj, attributes=None, update_metadata: int = 1) -> None: ...
    def unindex(self, obj) -> None: ...
    def begin(self) -> None: ...
    def commit(self) -> None: ...
    def abort(self) -> None: ...
    @staticmethod
    def get_dispatcher(obj, name):
        """return named indexing method according on the used mixin class"""

def getQueue():
    """return a (thread-local) queue object, create one if necessary"""

def processQueue():
    """process the queue (for this thread) immediately"""

class PathProxy(ProxyBase):
    def __init__(self, obj) -> None: ...
    @non_overridable
    def getPhysicalPath(self): ...

def wrap(obj):
    """the indexing key, i.e. the path to the object in the case of the
    portal catalog, might have changed while the unindex operation was
    delayed, for example due to renaming the object;  it was probably not
    such a good idea to use a key that can change in the first place, but
    to work around this a proxy object is used, which can provide the
    original path;  of course, access to other attributes must still be
    possible, since alternate indexers (i.e. solr etc) might use another
    unique key, usually the object's uid;  also the inheritence tree
    must match"""

class IndexQueue(local):
    queue: Incomplete
    tmhook: Incomplete
    def __init__(self) -> None: ...
    def hook(self) -> None:
        """register a hook into the transaction machinery if that hasn't
        already been done;  this is to make sure the queue's processing
        method gets called back just before the transaction is about to
        be committed"""
    def index(self, obj, attributes=None) -> None: ...
    def reindex(self, obj, attributes=None, update_metadata: int = 1) -> None: ...
    def unindex(self, obj) -> None: ...
    def setHook(self, hook) -> None: ...
    def getState(self): ...
    def setState(self, state) -> None: ...
    def length(self):
        """return number of currently queued items;  please note that
        we cannot use `__len__` here as this will cause test failures
        due to the way objects are compared"""
    def optimize(self) -> None: ...
    def process(self): ...
    def commit(self) -> None: ...
    def abort(self) -> None: ...
    def clear(self) -> None: ...

def filterTemporaryItems(obj, checkId: bool = True):
    """check if the item has an acquisition chain set up and is not of
    temporary nature, i.e. still handled by the `portal_factory`;  if
    so return it, else return None"""

class QueueSavepoint:
    """transaction savepoints using the IIndexQueue interface"""

    queue: Incomplete
    state: Incomplete
    def __init__(self, queue) -> None: ...
    def rollback(self) -> None: ...

class QueueTM(local):
    """transaction manager hook for the indexing queue"""

    registered: bool
    vote: bool
    queue: Incomplete
    def __init__(self, queue) -> None: ...
    def register(self) -> None: ...
    def savepoint(self): ...
    def tpc_begin(self, transaction) -> None: ...
    def commit(self, transaction) -> None: ...
    def before_commit(self) -> None: ...
    def tpc_vote(self, transaction) -> None: ...
    def tpc_finish(self, transaction) -> None: ...
    def tpc_abort(self, transaction) -> None: ...
    abort = tpc_abort
    def sortKey(self): ...
