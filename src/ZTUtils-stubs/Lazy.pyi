from _typeshed import Incomplete

class Lazy:
    __allow_access_to_unprotected_subobjects__: bool
    @property
    def actual_result_count(self): ...
    @actual_result_count.setter
    def actual_result_count(self, value) -> None: ...
    def __len__(self) -> int: ...
    def __add__(self, other): ...
    def __getitem__(self, index): ...

class LazyCat(Lazy):
    """Lazy concatenation of one or more sequences. Should be handy
    for accessing small parts of big searches.
    """

    actual_result_count: Incomplete
    def __init__(self, sequences, length=None, actual_result_count=None) -> None: ...
    def __getitem__(self, index): ...
    def __len__(self) -> int: ...

class LazyMap(Lazy):
    """Act like a sequence, but get data from a filtering process.
    Don't access data until necessary
    """

    actual_result_count: Incomplete
    def __init__(self, func, seq, length=None, actual_result_count=None) -> None: ...
    def __getitem__(self, index): ...

class LazyFilter(Lazy):
    """Act like a sequence, but get data from a filtering process.
    Don't access data until necessary. Only data for which test(data)
    returns true will be considered part of the set.
    """
    def __init__(self, test, seq) -> None: ...
    def __getitem__(self, index): ...

class LazyMop(Lazy):
    """Act like a sequence, but get data from a filtering process.
    Don't access data until necessary. If the filter raises an exception
    for a given item, then that item isn't included in the sequence.
    """
    def __init__(self, test, seq) -> None: ...
    def __getitem__(self, index): ...

class LazyValues(Lazy):
    """Given a sequence of two tuples typically (key, value) act as
    though we are just a list of the values lazily"""
    def __init__(self, seq) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index): ...
