from _typeshed import Incomplete
from plone.memoize.view import memoize
from Products.Five import BrowserView

class ManageContextualPortlets(BrowserView):
    def __init__(self, context, request) -> None: ...
    @property
    def macros(self): ...
    @property
    def category(self): ...
    @property
    def key(self): ...
    def getAssignmentMappingUrl(self, manager): ...
    def getAssignmentsForManager(self, manager): ...
    def has_legacy_portlets(self): ...
    def set_blacklist_status(
        self, manager, group_status, content_type_status, context_status
    ): ...
    def convert_legacy_portlets(self) -> None: ...

class ManageDashboardPortlets(BrowserView):
    @property
    def auth_token(self): ...
    @property
    def macros(self): ...
    @property
    def category(self): ...
    @property
    def key(self): ...
    def getAssignmentMappingUrl(self, manager): ...
    def getAssignmentsForManager(self, manager): ...

class ManageGroupDashboardPortlets(BrowserView):
    @property
    def group(self): ...
    @property
    def macros(self): ...
    @property
    def category(self): ...
    @property
    def key(self): ...
    def getAssignmentMappingUrl(self, manager): ...
    def getAssignmentsForManager(self, manager): ...

class ManageGroupPortlets(BrowserView):
    @property
    def macros(self): ...
    @property
    def category(self): ...
    @property
    def key(self): ...
    def __init__(self, context, request) -> None: ...
    def getAssignmentMappingUrl(self, manager): ...
    def getAssignmentsForManager(self, manager): ...
    def group(self): ...

class ManageContentTypePortlets(BrowserView):
    def __init__(self, context, request) -> None: ...
    @property
    def macros(self): ...
    @property
    def category(self): ...
    @property
    def key(self): ...
    def getAssignmentMappingUrl(self, manager): ...
    def getAssignmentsForManager(self, manager): ...
    def portal_type(self): ...
    @memoize
    def fti(self): ...

class ManagePortletsViewlet(BrowserView):
    """A general base class for viewlets that want to be rendered on the
    manage portlets view. This makes it possible to have a viewlet that
    renders a portlet manager, and still have the generic edit manager
    renderer work (it doesn't work otherwise, because the edit manager
    renderer is registered on IManagePortletsView, but inside a viewlet,
    the __parent__ is the viewlet, not the ultimate parent).
    """

    __parent__: Incomplete
    context: Incomplete
    request: Incomplete
    view: Incomplete
    manager: Incomplete
    def __init__(self, context, request, view, manager) -> None: ...
    @property
    def macros(self): ...
    @property
    def category(self): ...
    @property
    def key(self): ...
    def __getattribute__(self, name): ...
    def getAssignmentMappingUrl(self, manager): ...
    def getAssignmentsForManager(self, manager): ...
    @memoize
    def ultimate_parent(self): ...

class ManageContextualPortletsViewlet(ManagePortletsViewlet):
    """A viewlet base class for viewlets that need to render on the
    manage contextual portlets screen.
    """

class ManageGroupPortletsViewlet(ManagePortletsViewlet):
    """A viewlet base class for viewlets that need to render on the
    manage group portlets screen.
    """

class ManageContentTypePortletsViewlet(ManagePortletsViewlet):
    """A viewlet base class for viewlets that need to render on the
    manage content type portlets screen.
    """

class TopbarManagePortlets(ManageContextualPortlets):
    manager_name: str
    def __init__(self, context, request) -> None: ...
    def publishTraverse(self, request, name):
        """Get the portlet manager via traversal so that we can reuse
        the portlet machinery without overriding it all here.
        """
    def render_edit_manager_portlets(self): ...
