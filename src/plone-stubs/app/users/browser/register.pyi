from _typeshed import Incomplete
from plone.autoform.form import AutoExtensibleForm
from z3c.form import form

RENAME_AFTER_CREATION_ATTEMPTS: int

def getRegisterSchema(): ...

class BaseRegistrationForm(AutoExtensibleForm, form.Form):
    """Form to be used as base for Register and Add User forms."""

    label: str
    description: str
    formErrorsMessage: Incomplete
    ignoreContext: bool
    enableCSRFProtection: bool
    @property
    def schema(self): ...
    def render(self): ...
    def updateFields(self) -> None:
        """Fields are dynamic in this form, to be able to handle
        different join styles.
        """
    def updateActions(self) -> None: ...
    def generate_user_id(self, data):
        """Generate a user id from data.

        We try a few options for coming up with a good user id:

        1. We query a utility, so integrators can register a hook to
           generate a user id using their own logic.

        2. If use_uuid_as_userid is set in the registry, we
           generate a uuid.

        3. If a username is given and we do not use email as login,
           then we simply return that username as the user id.

        4. We create a user id based on the full name, if that is
           passed.  This may result in an id like bob-jones-2.

        When the email address is used as login name, we originally
        used the email address as user id as well.  This has a few
        possible downsides, which are the main reasons for the new,
        pluggable approach:

        - It does not work for some valid email addresses.

        - Exposing the email address in this way may not be wanted.

        - When the user later changes his email address, the user id
          will still be his old address.  It works, but may be
          confusing.

        Another possibility would be to simply generate a uuid, but that
        is ugly.  We could certainly try that though: the big plus here
        would be that you then cannot create a new user with the same user
        id as a previously existing user if this ever gets removed.  If
        you would get the same id, this new user would get the same global
        and local roles, if those have not been cleaned up.

        When a user id is chosen, the 'user_id' key of the data gets
        set and the user id is returned.
        """
    def generate_login_name(self, data):
        """Generate a login name from data.

        Usually the login name and user id are the same, but this is
        not necessarily true.  When using the email address as login
        name, we may have a different user id, generated by calling
        the generate_user_id method.

        We try a few options for coming up with a good login name:

        1. We query a utility, so integrators can register a hook to
           generate a login name using their own logic.

        2. If a username is given and we do not use email as login,
           then we simply return that username as the login name.

        3. When using email as login, we use the email address.

        In all cases, we call PAS.applyTransform on the login name, if
        that is defined.  This is a recent addition to PAS, currently
        under development.

        When a login name is chosen, the 'login_name' key of the data gets
        set and the login name is returned.
        """
    def validate_registration(self, action, data) -> None:
        """Specific business logic for this join form.  Note: all this logic
        was taken directly from the old validate_registration.py script in
        Products/CMFPlone/skins/plone_login/join_form_validate.vpy
        """
    status: Incomplete
    def action_join(self, action): ...
    def handle_join_success(self, data): ...
    def applyProperties(self, userid, data) -> None: ...

class RegistrationForm(BaseRegistrationForm):
    """Dynamically get fields from user data, through admin config settings."""

    label: Incomplete
    description: str
    template: Incomplete
    @property
    def showForm(self):
        """The form should not be displayed to the user if the system is
        incapable of sending emails and email validation is switched on
        (users are not allowed to select their own passwords).
        """
    fields: Incomplete
    def updateFields(self) -> None: ...
    def updateWidgets(self) -> None: ...

class AddUserForm(BaseRegistrationForm):
    label: Incomplete
    description: str
    template: Incomplete
    fields: Incomplete
    def updateFields(self) -> None: ...
    def updateWidgets(self) -> None: ...
    status: Incomplete
    def action_join(self, action) -> None: ...
